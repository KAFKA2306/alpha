"""
Integration script for generated blocks into the extended registry

This script loads the generated blocks and integrates them into the
extended domain block registry system.
"""

import json
import os
import sys
from typing import Dict, Any, List


def mock_torch_imports():
    """Mock torch imports for integration without installation"""
    import sys
    from unittest.mock import MagicMock
    
    # Mock torch
    torch_mock = MagicMock()
    torch_mock.nn = MagicMock()
    torch_mock.nn.Module = object
    torch_mock.nn.Linear = MagicMock
    torch_mock.nn.LayerNorm = MagicMock
    torch_mock.randn = lambda *args: [0] * (args[0] if args else 1)
    torch_mock.tensor = lambda x: x
    
    sys.modules['torch'] = torch_mock
    sys.modules['torch.nn'] = torch_mock.nn
    sys.modules['torch.nn.functional'] = MagicMock()
    
    # Mock numpy
    numpy_mock = MagicMock()
    numpy_mock.mean = lambda x: 0.5
    numpy_mock.prod = lambda x: 1
    sys.modules['numpy'] = numpy_mock


def load_generated_blocks(blocks_dir: str = "generated_blocks") -> List[Dict[str, Any]]:
    """Load generated blocks from JSON file"""
    
    blocks_file = os.path.join(blocks_dir, "generated_blocks.json")
    
    if not os.path.exists(blocks_file):
        raise FileNotFoundError(f"Generated blocks file not found: {blocks_file}")
    
    with open(blocks_file, 'r') as f:
        blocks = json.load(f)
    
    print(f"Loaded {len(blocks)} generated blocks from {blocks_file}")
    return blocks


def create_extended_registry_with_generated_blocks(generated_blocks: List[Dict[str, Any]]) -> str:
    """Create an updated extended registry file with generated blocks"""
    
    mock_torch_imports()
    from block_factory import create_block_factory
    
    # Create block factory to convert specs to blocks
    factory = create_block_factory()
    
    # Convert block specs to block objects (without actual PyTorch modules)
    converted_blocks = []
    
    for spec in generated_blocks:
        # Create a mock GeneratedDomainBlock for registry
        mock_block = type('MockGeneratedBlock', (), {
            'name': spec['name'],
            'category': spec['category'],
            'description': spec['description'],
            'parameters': spec['parameters'],
            'complexity': spec['complexity'],
            'components': spec['components'],
            'template_name': spec['template_name'],
            'get_hyperparameters': lambda self: self.parameters,
            'create_module': lambda self, input_shape, **kwargs: None,
            'get_output_shape': lambda self, input_shape, **kwargs: input_shape,
            'validate_input_shape': lambda self, input_shape: True
        })()
        
        converted_blocks.append(mock_block)
    
    # Generate the new extended registry file
    registry_code = generate_extended_registry_code(converted_blocks)
    
    # Save to new file
    output_file = "domain_blocks_mass_generated.py"
    with open(output_file, 'w') as f:
        f.write(registry_code)
    
    print(f"Created extended registry with {len(converted_blocks)} generated blocks: {output_file}")
    return output_file


def generate_extended_registry_code(blocks: List[Any]) -> str:
    """Generate Python code for extended registry with generated blocks"""
    
    # Group blocks by category
    blocks_by_category = {}
    for block in blocks:
        cat = block.category
        if cat not in blocks_by_category:
            blocks_by_category[cat] = []
        blocks_by_category[cat].append(block)
    
    # Generate the code
    code = '''"""
Mass Generated Domain Blocks Registry

This file contains all the domain blocks generated by the mass production system.
These blocks extend the original domain_blocks_extended.py with hundreds of new
diverse blocks for financial AI agent architecture exploration.

Auto-generated on: {timestamp}
Total blocks: {total_blocks}
Categories: {categories}
"""

from typing import Dict, Any, List, Optional, Union, Tuple
import torch
import torch.nn as nn
import torch.nn.functional as F
import numpy as np
from domain_blocks import DomainBlock, DomainBlockRegistry
from block_factory import GeneratedDomainBlock, create_block_factory


class MassGeneratedDomainBlockRegistry(DomainBlockRegistry):
    """Registry containing all mass-generated domain blocks."""
    
    def __init__(self):
        super().__init__()
        self.block_factory = create_block_factory()
        self._register_generated_blocks()
    
    def _register_generated_blocks(self):
        """Register all generated domain blocks."""
        
        # Generated block specifications
        generated_specs = {generated_blocks_data}
        
        print(f"Registering {{len(generated_specs)}} generated blocks...")
        
        for spec in generated_specs:
            try:
                # Create the block using factory
                block = self._create_generated_block(spec)
                self.register_block(block)
            except Exception as e:
                print(f"Error registering block {{spec['name']}}: {{e}}")
                continue
        
        print(f"Successfully registered {{len(self._blocks)}} total blocks")
    
    def _create_generated_block(self, spec: Dict[str, Any]) -> GeneratedDomainBlock:
        """Create a generated domain block from specification"""
        
        # Get the appropriate module factory
        factory_func = self.block_factory.module_factories.get(spec['category'])
        if factory_func is None:
            raise ValueError(f"No factory for category: {{spec['category']}}")
        
        # Create the block
        block = GeneratedDomainBlock(spec, factory_func)
        return block
    
    def get_blocks_by_complexity(self, complexity: str) -> List[DomainBlock]:
        """Get blocks by complexity level"""
        return [
            block for block in self._blocks.values() 
            if hasattr(block, 'complexity') and block.complexity == complexity
        ]
    
    def get_blocks_by_component(self, component: str) -> List[DomainBlock]:
        """Get blocks that contain a specific component"""
        return [
            block for block in self._blocks.values()
            if hasattr(block, 'components') and component in block.components
        ]
    
    def print_generation_summary(self):
        """Print summary of generated blocks"""
        print("=" * 80)
        print("MASS GENERATED DOMAIN BLOCKS SUMMARY")
        print("=" * 80)
        
        total_blocks = len(self._blocks)
        print(f"Total blocks: {{total_blocks}}")
        
        # Category breakdown
        category_counts = self.get_block_count_by_category()
        print(f"\\nCategory distribution:")
        for category, count in sorted(category_counts.items()):
            percentage = (count / total_blocks) * 100
            print(f"  {{category}}: {{count}} blocks ({{percentage:.1f}}%)")
        
        # Complexity breakdown
        complexity_counts = {{'simple': 0, 'medium': 0, 'complex': 0}}
        for block in self._blocks.values():
            if hasattr(block, 'complexity'):
                comp = block.complexity
                complexity_counts[comp] = complexity_counts.get(comp, 0) + 1
        
        print(f"\\nComplexity distribution:")
        for complexity, count in sorted(complexity_counts.items()):
            percentage = (count / total_blocks) * 100
            print(f"  {{complexity}}: {{count}} blocks ({{percentage:.1f}}%)")
        
        # Sample blocks
        print(f"\\nSample generated blocks:")
        sample_blocks = list(self._blocks.values())[:10]
        for i, block in enumerate(sample_blocks):
            print(f"  {{i+1}}. {{block.name}} ({{block.category}})")
            if hasattr(block, 'description'):
                desc = block.description[:60] + "..." if len(block.description) > 60 else block.description
                print(f"     {{desc}}")


# Create global mass generated registry instance
mass_generated_registry = MassGeneratedDomainBlockRegistry()


def get_mass_generated_registry() -> MassGeneratedDomainBlockRegistry:
    """Get the global mass generated registry."""
    return mass_generated_registry


if __name__ == "__main__":
    # Print summary when run as script
    registry = get_mass_generated_registry()
    registry.print_generation_summary()
'''.format(
        timestamp="2025-07-04 (Auto-generated)",
        total_blocks=len(blocks),
        categories=len(blocks_by_category),
        generated_blocks_data=_format_blocks_for_code(blocks)
    )
    
    return code


def _format_blocks_for_code(blocks: List[Any]) -> str:
    """Format blocks data for embedding in Python code"""
    
    # Convert blocks to serializable format
    blocks_data = []
    for block in blocks:
        block_data = {
            'name': block.name,
            'category': block.category,
            'description': block.description,
            'parameters': block.parameters,
            'complexity': block.complexity,
            'components': block.components,
            'template_name': block.template_name
        }
        blocks_data.append(block_data)
    
    # Format as Python list
    return str(blocks_data).replace("'", '"')


def create_integration_summary(generated_blocks: List[Dict[str, Any]], output_file: str):
    """Create integration summary"""
    
    summary_file = "integration_summary.md"
    
    with open(summary_file, 'w') as f:
        f.write("# Domain Block Integration Summary\n\n")
        f.write(f"Integration completed at: {__import__('datetime').datetime.now()}\n\n")
        
        f.write("## Integration Results\n\n")
        f.write(f"- Generated blocks loaded: {len(generated_blocks)}\n")
        f.write(f"- Extended registry file: {output_file}\n")
        f.write(f"- Registry class: MassGeneratedDomainBlockRegistry\n\n")
        
        # Category summary
        category_counts = {}
        for block in generated_blocks:
            cat = block['category']
            category_counts[cat] = category_counts.get(cat, 0) + 1
        
        f.write("## Block Categories\n\n")
        for category, count in sorted(category_counts.items()):
            f.write(f"- {category}: {count} blocks\n")
        
        f.write("\n## Usage\n\n")
        f.write("```python\n")
        f.write("# Import the mass generated registry\n")
        f.write("from domain_blocks_mass_generated import get_mass_generated_registry\n\n")
        f.write("# Get the registry\n")
        f.write("registry = get_mass_generated_registry()\n\n")
        f.write("# Print summary\n")
        f.write("registry.print_generation_summary()\n\n")
        f.write("# Get blocks by category\n")
        f.write("attention_blocks = registry.get_blocks_by_category('attention')\n")
        f.write("financial_blocks = registry.get_blocks_by_category('financial_domain')\n\n")
        f.write("# Get blocks by complexity\n")
        f.write("complex_blocks = registry.get_blocks_by_complexity('complex')\n")
        f.write("```\n\n")
        
        f.write("## Next Steps\n\n")
        f.write("1. Test the generated blocks with actual PyTorch modules\n")
        f.write("2. Validate block functionality and performance\n")
        f.write("3. Integrate into AI agent architecture exploration\n")
        f.write("4. Run diversity and effectiveness analysis\n")
    
    print(f"Created integration summary: {summary_file}")


def main():
    """Main integration function"""
    
    print("=" * 80)
    print("DOMAIN BLOCK INTEGRATION")
    print("=" * 80)
    
    try:
        # Load generated blocks
        generated_blocks = load_generated_blocks()
        
        # Create extended registry
        output_file = create_extended_registry_with_generated_blocks(generated_blocks)
        
        # Create summary
        create_integration_summary(generated_blocks, output_file)
        
        print("\n" + "=" * 80)
        print("INTEGRATION COMPLETE")
        print("=" * 80)
        print(f"Generated blocks: {len(generated_blocks)}")
        print(f"Registry file: {output_file}")
        print(f"Summary: integration_summary.md")
        
        return True
        
    except Exception as e:
        print(f"Integration failed: {e}")
        import traceback
        traceback.print_exc()
        return False


if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)